#pragma kernel NormalsFromDepth

#include "../../Common.hlsl"

RWTexture2D<float> DepthResult;
RWTexture2D<float3> NormalResult;
uint Width, Height, DispatchSizeX, DispatchSizeY;

// Normally argument "dipatchGridDim" is parsed through a constant buffer. However, if for some reason it is a
// static value, some DXC compiler versions will be unable to compile the code.
// If that's the case for you, flip DXC_STATIC_DISPATCH_GRID_DIM definition from 0 to 1.
#define DXC_STATIC_DISPATCH_GRID_DIM 0

// Divide the 2D-Dispatch_Grid into tiles of dimension [N, DipatchGridDim.y]
// "CTA" (Cooperative Thread Array) == Thread Group in DirectX terminology
uint2 ThreadGroupTilingX(
	const uint2 dipatchGridDim,		// Arguments of the Dispatch call (typically from a ConstantBuffer)
	const uint2 ctaDim,			// Already known in HLSL, eg:[numthreads(8, 8, 1)] -> uint2(8, 8)
	const uint maxTileWidth,		// User parameter (N). Recommended values: 8, 16 or 32.
	const uint2 groupThreadID,		// SV_GroupThreadID
	const uint2 groupId			// SV_GroupID
)
{
	// A perfect tile is one with dimensions = [maxTileWidth, dipatchGridDim.y]
	const uint Number_of_CTAs_in_a_perfect_tile = maxTileWidth * dipatchGridDim.y;

	// Possible number of perfect tiles
	const uint Number_of_perfect_tiles = dipatchGridDim.x / maxTileWidth;

	// Total number of CTAs present in the perfect tiles
	const uint Total_CTAs_in_all_perfect_tiles = Number_of_perfect_tiles * maxTileWidth * dipatchGridDim.y;
	const uint vThreadGroupIDFlattened = dipatchGridDim.x * groupId.y + groupId.x;

	// Tile_ID_of_current_CTA : current CTA to TILE-ID mapping.
	const uint Tile_ID_of_current_CTA = vThreadGroupIDFlattened / Number_of_CTAs_in_a_perfect_tile;
	const uint Local_CTA_ID_within_current_tile = vThreadGroupIDFlattened % Number_of_CTAs_in_a_perfect_tile;
	uint Local_CTA_ID_y_within_current_tile;
	uint Local_CTA_ID_x_within_current_tile;

	if (Total_CTAs_in_all_perfect_tiles <= vThreadGroupIDFlattened)
	{
		// Path taken only if the last tile has imperfect dimensions and CTAs from the last tile are launched. 
		uint X_dimension_of_last_tile = dipatchGridDim.x % maxTileWidth;
	#ifdef DXC_STATIC_DISPATCH_GRID_DIM
		X_dimension_of_last_tile = max(1, X_dimension_of_last_tile);
	#endif
		Local_CTA_ID_y_within_current_tile = Local_CTA_ID_within_current_tile / X_dimension_of_last_tile;
		Local_CTA_ID_x_within_current_tile = Local_CTA_ID_within_current_tile % X_dimension_of_last_tile;
	}
	else
	{
		Local_CTA_ID_y_within_current_tile = Local_CTA_ID_within_current_tile / maxTileWidth;
		Local_CTA_ID_x_within_current_tile = Local_CTA_ID_within_current_tile % maxTileWidth;
	}

	const uint Swizzled_vThreadGroupIDFlattened =
		Tile_ID_of_current_CTA * maxTileWidth +
		Local_CTA_ID_y_within_current_tile * dipatchGridDim.x +
		Local_CTA_ID_x_within_current_tile;

	uint2 SwizzledvThreadGroupID;
	SwizzledvThreadGroupID.y = Swizzled_vThreadGroupIDFlattened / dipatchGridDim.x;
	SwizzledvThreadGroupID.x = Swizzled_vThreadGroupIDFlattened % dipatchGridDim.x;

	uint2 SwizzledvThreadID;
	SwizzledvThreadID.x = ctaDim.x * SwizzledvThreadGroupID.x + groupThreadID.x;
	SwizzledvThreadID.y = ctaDim.y * SwizzledvThreadGroupID.y + groupThreadID.y;

	return SwizzledvThreadID.xy;
}

const static uint NumThreadsX = 16;
const static uint NumThreadsY = 8;

[numthreads(NumThreadsX, NumThreadsY, 1)]
void NormalsFromDepth(uint2 id : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
	float depth = _CameraDepth[id];
	//if(depth == 0.0)
	//	return;
	
	float3 worldPosition = PixelToWorld(float3(id + 0.5, depth));

	float4 H;
	H.x = _CameraDepth[id - uint2(1, 0)];
	H.y = _CameraDepth[id + uint2(1, 0)];
	H.z = _CameraDepth[id - uint2(2, 0)];
	H.w = _CameraDepth[id + uint2(2, 0)];

	float2 he = abs((2 * H.xy - H.zw) - depth);
	float3 hDeriv;
	if (he.x > he.y)
	{
		hDeriv = PixelToWorld(float3(id + 0.5 + float2(1.0, 0.0), H.y)) - worldPosition;
	}
	else
	{
		hDeriv = worldPosition - PixelToWorld(float3(id + 0.5 + float2(-1.0, 0.0), H.x));
	}
    
	float4 v;
	v.x = _CameraDepth[id - uint2(0, 1)];
	v.y = _CameraDepth[id + uint2(0, 1)];
	v.z = _CameraDepth[id - uint2(0, 2)];
	v.w = _CameraDepth[id + uint2(0, 2)];
	
	float2 ve = abs((2 * v.xy - v.zw) - depth);
	float3 vDeriv;
	if (ve.x > ve.y)
	{
		vDeriv = PixelToWorld(float3(id + 0.5 + float2(0.0, 1.0), v.y)) - worldPosition;
	}
	else
	{
		vDeriv = worldPosition - PixelToWorld(float3(id + 0.5 + float2(0.0, -1.0), v.x));
	}
		
	float3 worldNormal = cross(vDeriv, hDeriv);
	float3 normalV = normalize(mul((float3x3) unity_MatrixV, worldNormal) * float3(1, 1, -1));

	NormalResult[id] = normalV * 0.5 + 0.5;
	DepthResult[id] = Linear01Depth(depth);
}
