#include "../Common.hlsl"

#pragma kernel DirectionalAlbedo
#pragma kernel AverageAlbedo
#pragma kernel DirectionalAlbedoMs
#pragma kernel AverageAlbedoMs
#pragma kernel SpecularOcclusion

RWTexture3D<float> _DirectionalAlbedoMsResult;
RWTexture2D<float2> _DirectionalAlbedoResult;
RWTexture2D<float> _AverageAlbedoResult, _AverageAlbedoMsResult;

float2 _DirectionalAlbedoScaleOffset;
uint _DirectionalAlbedoSamples;
float _DirectionalAlbedoSamplesRcp;

float4 _DirectionalAlbedoRemap;
float2 _AverageAlbedoRemap;
float _AverageAlbedoScaleOffset;
uint _AverageAlbedoSamples;
float _AverageAlbedoSamplesRcp;
float _AverageAlbedoSamplesMinusOneRcp;

uint _DirectionalAlbedoMsSamples;
float _DirectionalAlbedoMsSamplesRcp;
float3 _DirectionalAlbedoMsScaleOffset;

uint _AverageAlbedoMsSamples;
float _AverageAlbedoMsSamplesRcp;
float2 _AverageAlbedoMsScaleOffset;
float _AverageAlbedoMsSamplesMinusOneRcp;

Texture3D<float> _GGXDirectionalAlbedoMS;
Texture2D<float2> _GGXDirectionalAlbedo;
Texture2D<float> _GGXAverageAlbedo, _GGXAverageAlbedoMS;

cbuffer GGXLookupConstants
{
	float4 _GGXDirectionalAlbedoRemap;
	float2 _GGXAverageAlbedoRemap;
	float2 _GGXDirectionalAlbedoMSScaleOffset;
	float4 _GGXAverageAlbedoMSRemap;
};

float2 GGXDirectionalAlbedo(float NdotV, float perceptualRoughness)
{
	float2 uv = float2(sqrt(NdotV), perceptualRoughness) * _GGXDirectionalAlbedoRemap.xy + _GGXDirectionalAlbedoRemap.zw;
	return _GGXDirectionalAlbedo.SampleLevel(_LinearClampSampler, uv, 0);
}

float GGXAverageAlbedo(float perceptualRoughness)
{
	float2 averageUv = float2(perceptualRoughness * _GGXAverageAlbedoRemap.x + _GGXAverageAlbedoRemap.y, 0.0);
	return _GGXAverageAlbedo.SampleLevel(_LinearClampSampler, averageUv, 0.0);
}

float GGXDirectionalAlbedoMS(float NdotV, float perceptualRoughness, float f0)
{
	float3 uv = float3(sqrt(NdotV), perceptualRoughness, f0) * _GGXDirectionalAlbedoMSScaleOffset.x + _GGXDirectionalAlbedoMSScaleOffset.y;
	return _GGXDirectionalAlbedoMS.SampleLevel(_LinearClampSampler, uv, 0.0);
}

float GGXAverageAlbedoMS(float perceptualRoughness, float f0)
{
	float2 uv = float2(perceptualRoughness, f0) * _GGXAverageAlbedoMSRemap.xy + _GGXAverageAlbedoMSRemap.zw;
	return _GGXAverageAlbedoMS.SampleLevel(_LinearClampSampler, uv, 0.0);
}

void SampleGGXDir(float2 u, float3 V, float3x3 localToWorld, float roughness, out float3 L, out float NdotL, out float NdotH, out float VdotH, bool VeqN = false)
{
    // GGX NDF sampling
	float cosTheta = sqrt(SafeDiv(1.0 - u.x, 1.0 + (roughness * roughness - 1.0) * u.x));
	float phi = TwoPi * u.y;

	float3 localH = SphericalToCartesian(phi, cosTheta);

	NdotH = cosTheta;

	float3 localV;

	if (VeqN)
	{
        // localV == localN
		localV = float3(0.0, 0.0, 1.0);
		VdotH = NdotH;
	}
	else
	{
		localV = mul(V, transpose(localToWorld));
		VdotH = saturate(dot(localV, localH));
	}

    // Compute { localL = reflect(-localV, localH) }
	float3 localL = -localV + 2.0 * VdotH * localH;
	NdotL = localL.z;

	L = mul(localL, localToWorld);
}

// Note: V = G / (4 * NdotL * NdotV)
// Ref: http://jcgt.org/published/0003/02/03/paper.pdf
float V_SmithJointGGX(float NdotL, float NdotV, float roughness, float partLambdaV)
{
	float a2 = Sq(roughness);

    // Original formulation:
    // lambda_v = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5
    // lambda_l = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5
    // G        = 1 / (1 + lambda_v + lambda_l);

    // Reorder code to be more optimal:
	float lambdaV = NdotL * partLambdaV;
	float lambdaL = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);

    // Simplify visibility term: (2.0 * NdotL * NdotV) /  ((4.0 * NdotL * NdotV) * (lambda_v + lambda_l))
	return 0.5 / max(lambdaV + lambdaL, FloatMin);
}

// Precompute part of lambdaV
float GetSmithJointGGXPartLambdaV(float NdotV, float roughness)
{
	float a2 = Sq(roughness);
	return sqrt((-NdotV * a2 + NdotV) * NdotV + a2);
}

float V_SmithJointGGX(float NdotL, float NdotV, float roughness)
{
	float partLambdaV = GetSmithJointGGXPartLambdaV(NdotV, roughness);
	return V_SmithJointGGX(NdotL, NdotV, roughness, partLambdaV);
}

// weightOverPdf return the weight (without the Fresnel term) over pdf. Fresnel term must be apply by the caller.
void ImportanceSampleGGX(float2 u, float3 V, float3x3 localToWorld, float roughness, float NdotV, out float3 L, out float VdotH, out float NdotL, out float weightOverPdf)
{
	float NdotH;
	SampleGGXDir(u, V, localToWorld, roughness, L, NdotL, NdotH, VdotH);

    // Importance sampling weight for each sample
    // pdf = D(H) * (N.H) / (4 * (L.H))
    // weight = fr * (N.L) with fr = F(H) * G(V, L) * D(H) / (4 * (N.L) * (N.V))
    // weight over pdf is:
    // weightOverPdf = F(H) * G(V, L) * (L.H) / ((N.H) * (N.V))
    // weightOverPdf = F(H) * 4 * (N.L) * V(V, L) * (L.H) / (N.H) with V(V, L) = G(V, L) / (4 * (N.L) * (N.V))
    // Remind (L.H) == (V.H)
    // F is apply outside the function

	float Vis = V_SmithJointGGX(NdotL, NdotV, roughness);
	weightOverPdf = 4.0 * Vis * NdotL * VdotH / NdotH;
}

[numthreads(8, 8, 1)]
void DirectionalAlbedo(uint2 id : SV_DispatchThreadID)
{
	float2 uv = id * _DirectionalAlbedoScaleOffset;

	float NdotV = max(uv.x * uv.x, HalfEps);
	float roughness = uv.y * uv.y;
	float3 V = float3(SinFromCos(NdotV), 0, NdotV);

	float2 result = 0.0;
	for (uint i = 0; i < _DirectionalAlbedoSamples; i++)
	{
		float2 u = Hammersley2dSeq(i, _DirectionalAlbedoSamples);

		float VdotH, NdotL, weightOverPdf;
		float3 L; // Unused
		ImportanceSampleGGX(u, V, Identity3x3, roughness, NdotV, L, VdotH, NdotL, weightOverPdf);

		if (NdotL > 0.0)
		{
			result.x += weightOverPdf * pow(1 - VdotH, 5);
			result.y += weightOverPdf;
		}
	}

	_DirectionalAlbedoResult[id] = result * _DirectionalAlbedoSamplesRcp;
}

[numthreads(32, 1, 1)]
void AverageAlbedo(uint2 id : SV_DispatchThreadID)
{
	float result = 0.0;
	float perceptualRoughness = id.x * _AverageAlbedoScaleOffset;

	for (uint i = 0.0; i < _AverageAlbedoSamples; i++)
	{
		float NdotV = i * _AverageAlbedoSamplesMinusOneRcp;
		result += GGXDirectionalAlbedo(NdotV, perceptualRoughness).g * NdotV;
	}

	_AverageAlbedoResult[id] = 2.0 * result * _AverageAlbedoSamplesRcp;
}

// Variant with float3 for f90
float3 F_Schlick(float3 f0, float u)
{
	float x = 1.0 - u;
	float x2 = x * x;
	float x5 = x * x2 * x2;
	return f0 * (1.0 - x5) + (1.0 * x5); // sub mul mul mul sub mul mad*3
}

float D_GGXNoPI(float NdotH, float roughness)
{
	float a2 = Sq(roughness);
	float s = (NdotH * a2 - NdotH) * NdotH + 1.0;

    // If roughness is 0, returns (NdotH == 1 ? 1 : 0).
    // That is, it returns 1 for perfect mirror reflection, and 0 otherwise.
	return SafeDiv(a2, s * s);
}

float D_GGX(float NdotH, float roughness)
{
	return RcpPi * D_GGXNoPI(NdotH, roughness);
}

float3 GGXMultiScatter(float NdotV, float NdotL, float perceptualRoughness, float3 f0)
{
	float Ewi = GGXDirectionalAlbedo(NdotV, perceptualRoughness).g;
	float Ewo = GGXDirectionalAlbedo(NdotL, perceptualRoughness).g;
	float Eavg = GGXAverageAlbedo(perceptualRoughness);

	float ms = RcpPi * (1.0 - Ewi) * (1.0 - Ewo) * rcp(max(HalfEps, 1.0 - Eavg));

	float3 FAvg = AverageFresnel(f0);
	float3 f = Sq(FAvg) * Eavg * rcp(max(HalfEps, 1.0 - FAvg * (1.0 - Eavg)));
	return ms * f;
}

[numthreads(8, 8, 8)]
void DirectionalAlbedoMs(uint3 id : SV_DispatchThreadID)
{
	float3 uv = id * _DirectionalAlbedoMsScaleOffset;

	float NdotV = max(uv.x * uv.x, HalfEps);
	float perceptualRoughness = uv.y;
	float roughness = PerceptualRoughnessToRoughness(perceptualRoughness);
	float f0 = uv.z;

	float3 V = float3(SinFromCos(NdotV), 0, NdotV);

	float result = 0.0;
	for (uint i = 0; i < _DirectionalAlbedoMsSamples; i++)
	{
		float2 u = Hammersley2dSeq(i, _DirectionalAlbedoMsSamples);

		float NdotL, NdotH, VdotH;
		float3 L; // Unused
		SampleGGXDir(u, V, Identity3x3, roughness, L, NdotL, NdotH, VdotH);

		if (NdotL > 0.0)
		{
			float F = F_Schlick(f0, VdotH);
			float D = D_GGX(NdotH, roughness);
			float V = V_SmithJointGGX(NdotL, NdotV, roughness);
			float ms = GGXMultiScatter(NdotV, NdotL, perceptualRoughness, f0).r;

			float weightOverPdf = 4.0 * NdotL * VdotH * (F * D * V + ms) / (D * NdotH);

			result += weightOverPdf;
		}
	}

	_DirectionalAlbedoMsResult[id] = result * _DirectionalAlbedoMsSamplesRcp;
}

[numthreads(32, 1, 1)]
void AverageAlbedoMs(uint2 id : SV_DispatchThreadID)
{
	float2 uv = id * _AverageAlbedoMsScaleOffset;

	float perceptualRoughness = uv.x;
	float f0 = uv.y;

	float result = 0.0;
	for (uint i = 0.0; i < _AverageAlbedoMsSamples; i++)
	{
		float NdotV = i * _AverageAlbedoMsSamplesMinusOneRcp;
		result += GGXDirectionalAlbedoMS(NdotV, perceptualRoughness, f0) * NdotV;
	}

	_AverageAlbedoMsResult[id] = 2.0 * result * _AverageAlbedoMsSamplesRcp;
}

static const uint _SpecularOcclusionSamples = 4096;
uint _SpecularOcclusionResolution;
RWTexture3D<float> _SpecularOcclusionResult;

[numthreads(8, 8, 8)]
void SpecularOcclusion(uint3 id : SV_DispatchThreadID)
{
	uint z = id.z % _SpecularOcclusionResolution;
	uint w = id.z / _SpecularOcclusionResolution;

	float4 uv = uint4(id.xy, z, w) / (_SpecularOcclusionResolution - 1.0);

	float NdotV = max(HalfEps, uv.x);
	float roughness = max(1e-3, uv.y);
	
	float alphaV = acos(sqrt(1.0 - uv.z));
	float beta = acos(uv.w);
	float theta = acos(NdotV);

	float3 V = float3(SinFromCos(NdotV), 0, NdotV);
	float3 B = float3(sin(beta - theta), 0.0, cos(beta - theta));
	
	float2 result = 0.0;
	for (uint i = 0; i < _SpecularOcclusionSamples; i++)
	{
		float2 u = Hammersley2dSeq(i, _SpecularOcclusionSamples);

		float VdotH, NdotL, weightOverPdf;
		float3 L;
		ImportanceSampleGGX(u, V, Identity3x3, roughness, NdotV, L, VdotH, NdotL, weightOverPdf);

		if (NdotL > 0.0)
		{
			result.x += weightOverPdf * (acos(dot(B, L)) <= alphaV);
			result.y += weightOverPdf;
		}

		_SpecularOcclusionResult[id] = result.x / result.y;
	}
}